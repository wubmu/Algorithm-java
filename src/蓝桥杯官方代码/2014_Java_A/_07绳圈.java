/*
标题：绳圈

    今有 100 根绳子，当然会有 200 个绳头。

    如果任意取绳头两两配对，把所有绳头都打结连接起来。最后会形成若干个绳圈（不考虑是否套在一起）。

    我们的问题是：请计算最后将形成多少个绳圈的概率最大？

    注意：结果是一个整数，请通过浏览器提交该数字。不要填写多余的内容。
*/
/*
 c[i]表示i条绳的2i个端点配对的种数，有c[1]=1，c[i]=c[i-1]*(2i-1)——>
 第i根绳子加入既有组合，对于i-1根绳子的每一种配对，有
    A.(i-1)个对儿可以从任意一对儿拆开将新绳子接入而且接入方法有两种，这是2(i-1)种接入方法
    B.或者自己成一对儿不影响原有配对，这是1种接入方法
 因此c[i]有c[i-1]*(2i-1)种配对方法

 设f[i][j]表示i条绳结成j个圈的概率，
 于是有f[i][i]=1/c[i]——>f[i][i]表示i根绳i个圈，只有一种配对方法，而全部配对方法为c[i]
 f[i][1]=f[i-1][1]*c[i-1]*(i-1)*2/c[i]，——>i根绳1个圈的概率=i-1根绳子围成1个圈的概率*总数 （即配对数）
 有（i-1）个地方可以断开接入 得出配对数，然后除以总数得概率
 进一步f[i][j]=(f[i-1][j]*c[i-1]*(i-1)*2+f[i-1][j-1]*c[i-1])/c[i]，——fij=
    情况1：维持j个圈，有i-1个地方可以断开将新绳子接入f[i-1][j]*c[i-1]*(i-1)*2
    情况2：i-1根绳子组成j-1个圈，新绳子自成一圈
    两种情况相加➗总数得出概率
再根据c[i]和c[i-1]的递推关系将c[i]和c[i-1]约去得到：f[i][j]=(f[i-1][j]*(i-1)*2+f[i-1][j-1])/(2i-1)


*/
public class _07绳圈 {
  public static void main(String[] args) {
    double f[][] = new double[101][101];
    f[1][1] = 1;
    for (int sheng = 2; sheng <= 100; sheng++) {
      f[sheng][1] = f[sheng - 1][1] * (sheng - 1) * 2 / (2 * sheng - 1);
      for (int quan = 2; quan <= sheng; quan++) {
        f[sheng][quan] = (f[sheng - 1][quan] * (sheng - 1) * 2 + f[sheng - 1][quan - 1]) / (2 * sheng - 1);
      }
    }

    double max = -1;
    int ans = -1;
    for (int i = 1; i <= 100; i++) {
      if (f[100][i] > max) {
        max = f[100][i];
        ans = i;
      }
    }
    System.out.println(ans);
  }
}
